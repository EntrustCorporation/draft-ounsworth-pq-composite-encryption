---
title: Composite Encryption For Use In Internet PKI
abbrev: PQ Composite Certs
# <!-- EDNOTE: Edits the draft name -->
docname: draft-ounsworth-pq-composite-encryption-00

# <!-- stand_alone: true -->
area: Security
wg: LAMPS
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth (Editor)
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 1000 Innovation Drive
      city: Ottawa, Ontario
      country: Canada
      code: K2K 1E3
      email: mike.ounsworth@entrust.com

    -
      ins: J. Gray
      name: John Gray
      org: Enrust Limited
      abbrev: Entrust
      email: john.gray@entrust.com

normative:
  RFC2119:
  RFC2986:
  RFC4210:
  RFC5280:
  RFC5652:
  RFC8174:
  RFC8411:
  X.690:
      title: "Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"
      date: November 2015
      author:
        org: ITU-T
      seriesinfo:
        ISO/IEC: 8825-1:2015


# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:

<!--updates:
  RFC2986
  RFC5280
  RFC5652 -->
# <!-- EDNOTE: does it update these anymore?? -->


# <!-- EDNOTE: Add RFC 3279? -->

--- abstract
With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data.


This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines id-composite-encryption which encrypts for a recipient with a composite public key by generating a shared secret for each of the recipient's component public keys and combining them into a single content encryption key using NIST SP 800-56Cr2.

<!-- End of Abstract -->


--- middle

# Introduction {#sec-intro}

During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, but we will also not fully trust their post-quantum replacements until they have had sufficient scrutiny. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.

The deployment of composite public keys and composite encryption using post-quantum algorithms will face two challenges

- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Backwards compatibility: During the transition period, post-quantum algorithms will not be supported by all clients.

This document provides a mechanism to address algorithm strength uncertainty by buliding on ~~ reference draft-ounsworth-pq-composite-pubkeys ~~ by providing formats for wrapping a content encryption key using multiple public key encryption mechanisms into existing fields. The issue of backwards compatibility is left open to be addressed in separate draft(s).

This document is intended for general applicability anywhere that content encryption is used within PKIX and CMS structures.


<!-- End of Introduction section -->


## Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

The following terms are used in this document:

ALGORITHM:
          An information object class for identifying the type of
            cryptographic operation to be performed. This document is
            primarily concerned with algorithms for producing digital
            signatures, though the public key structure could just as
            easily hold encryption keys.

BER:
          Basic Encoding Rules (BER) as defined in [X.690].

COMPONENT ALGORITHM:
          A single basic algorithm which is contained within a
            composite algorithm.

COMPOSITE ALGORITHM:
          An algorithm which is a sequence of one or more component
            algorithms, as defined in {{sec-composite-structs}}.

DER:
          Distinguished Encoding Rules as defined in [X.690].

PUBLIC / PRIVATE KEY:
          The public and private portion of an asymmetric cryptographic
            key, making no assumptions about which algorithm.

PRIMITIVE PUBLIC KEY / SIGNATURE:
          A public key or signature object of a non-composite algorithm
            type.

SIGNATURE:
          A digital cryptographic signature, making no assumptions
            about which algorithm.



# Composite Structures {#sec-composite-structs}

EDNOTE: TODO: RE-WORK THIS SECTION.

In order for public keys and signatures to be composed of multiple algorithms, we define encodings consisting of a sequence of public key and signature primitives (aka "component algorithms") such that these structures can be used as a drop-in replacement for existing public key or signature fields such as those found in PKCS#10 [RFC2986], CMP [RFC4210], X.509 [RFC5280], CMS [RFC5652].

This section defines the following structures:

  - The id-alg-composite is an OID identifying a composite signature object.

  - The CompositePrivateKey carries all the private keys associated with an identity within a single private key structure.

  - The CompositeSignatureValue, carries a sequence of signatures that are generated by a CompositePrivateKey, and can be verified with the corresponding CompositePublicKey.

EDNOTE 2: the choice to define composite algorithm parameters as a sequence inside the existing fields avoids the exponential proliferation of OIDs that are needed for each combination of signature algorithms in other schemes for achieving multi-key certificates. This scheme also naturally extends from 2-keypair to n-keypair keys and certificates.

EDNOTE 2a: We have heard community feedback that the ASN.1 structures presented here are too flexible in that allow arbitrary combinations of an arbitrary number of signature algorithms. The feedback is that this is too much of a "footgun" for implementors and sysadmins. We are working on an alternative formulation using ASN.1 information object classes that allow for compiling explicit pairs of algorithmIDs. We would love community feedback on which approach is preferred. See slide 30 of this presentation: https://datatracker.ietf.org/meeting/interim-2021-lamps-01/materials/slides-interim-2021-lamps-01-sessa-position-presentation-by-mike-ounsworth-00.pdf

## Algorithm Identifier {#sec-alg-identifier}

The same algorithm identifier is used for identifying a public key, a private key, and a signature.  Additional encoding information is provided below for each of these objects.

~~~ asn.1
id-alg-composite OBJECT IDENTIFIER ::= {
    iso(1)  identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) OpenCA(18227) Algorithms(2) id-alg-composite(1) }
~~~

EDNOTE 3: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

EDNOTE: should this be an instance of RFC 5652's KeyEncryptionAlgorithmIdentifier ?

## Composite Keys

A Composite encryption MUST be associated with a Composite public key as defined in ~~ reference draft-ounsworth-pq-composite-pubkey ~~. 


### Key Usage Bits

For protocols such as X.509 [RFC5280] that specify key usage along with the public key, then the composite public key associated with a composite signature MUST have a signing-type key usage.

If the keyUsage extension is present in an end-entity certificate whose keys are being used with id-alg-composite signatures, then the keyUsage extension MUST contain one or both of the following values:

~~~
    keyEncipherment; and
    dataEncipherment.
~~~
{: artwork-name="Cert-Key-Usage-1"}



## Composite Key Encryption {#sec-composite-encr-structs}

The composite content-encryption algorithm supports encryption and decryption operations. The encryption operation maps an octet string (the plaintext) to another octet string (the ciphertext) under control of a content-encryption key formed by combining multiple shared secrets each encrypted for a different recipient component public key. The decryption operation is the inverse of the encryption operation.  Context determines which operation is intended.


The id-alg-composite object identifier MUST be used to identify when an encrypted key has been created for decryption by a CompositePrivateKey. Composite encryption uses the following structure:

~~~ asn.1
CompositeEncryptedKey ::= EncryptedKey{ SEQUENCE SIZE (2..Max)  OF OCTET STRING}
~~~
{: artwork-name="CompositeEncryptionStructure"}

EDNOTE: Need to run this through an ASN.1 compiler and fix: intent is that this fits into any EncryptedKey field, but defines some stricture within the existing EncryptedKey ::= OCTET STRING. If wrapping it on the wire inside the EncryptedKey OID provides that, then great!

Where each OCTEC STRING within the SEQUENCE contains key material encrypted for one of the recipient's component keys. It MUST contain one signature value produced by each component algorithm, and in the same order as in the associated composite public key object.

The choice of `SEQUENCE OF OCTET STRING`, rather than a single OCTET STRING containing the concatenated signature values, is to gracefully handle variable-length ciphertext values by taking advantage of ASN.1's built-in length fields.

EDNOTE: do we need a CompositeParams to denote the list of component algorithms used, or will that be implied when the decryptor tries to use their private key? Need to take another look at RFC 5652 and CMP to see if there's even a spot to put CompositeParams in an encryption alg.

~~~ asn.1
CompositeParams ::= SEQUENCE SIZE (2..MAX) OF AlgorithmIdentifier
~~~
{: artwork-name="CompositeSignatureParams-asn.1-structures"}



## Encoding Rules {#sec-encoding-rules}
<!-- EDNOTE 7: Examples of how other specifications specify how a data structure is converted to a bit string can be found in RFC 2313, section 10.1.4, 3279 section 2.3.5, and RFC 4055, section 3.2. -->

EDNOTE: this section was copied from the composite-sigs draft. Does it apply here since I've defined it above as an OCTET STRING already?

Many protocol specifications will require that the composite public key, composite private key, and composite signature data structures be represented by an octet string or bit string.

When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.

When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

In the interests of simplicity and avoiding compatibility issues, implementations that parse these structures MAY accept both BER and DER.

# Composite encryption and decryption Processes {#sec-composite-encryption-algorithm}

This section specifies the algorithms for encrypting and decrypting using composite encryption.

This algorithm addresses algorithm strength uncertainty by establishing separate key material using each component algorithm, to be combined into the content encryption key using :: TODO: ref properly :: NIST SP 800-56Cr2.

## Composite encryption {#sec-comp-encr}

Generation of a CompositeEncryptedKey involves applying each component algorithm's encryption routine to a shared secret value according to its specification, and then placing each component value into the CompositeEncryptedKey structure defined in {{sec-composite-encr-structs}}.

The following algorithm is used to generate composite encrypted key values.

~~~
Input:
     P1, P2, .., Pn     Public keys for the n component encryption
                        algorithms, a CompositePublicKey
    
    SIZE                The size, in bits, for shared secrets to be combined by both 
                        parties into a content encryption key. This value SHOULD correspond
                        to the size of the content encryption key.

Output:
     E                  The encrypted value, a CompositeEncryptedKey

     SS1, SS2, .., SSn Key material in the form of a set of shared secrets.

Ciphertext Generation Procedure:
   1. Generate a set of shared secrets
        for i := 1 to n
          SSi := random_bits(SIZE)

   2. Generate the n component ciphertexts independently,
      according to their algorithm specifications.

        for i := 1 to n
            Ei := Encrypt( Pi, SSi )

   3. Encode each component ciphertext E1, E2, .., En into a OCTET STRING
      according to its algorithm specification.

        E ::= Sequence { E1, E2, .., En }

   4. Output E
      Output SS1, SS2, .., SSn
~~~
{: artwork-name="alg-composite-encr"}


Since recursive composite public keys are disallowed in ~~ Reference draft-ounsworth-pq-composite-pubkeys sec-composite-pub-keys ~~, no component ciphertext may itself be a composite; ie the composite encryption process MUST fail if one of the public keys K1, K2, .., Kn is a composite with the OID id-alg-composite.

A composite encryption MUST produce and include in the output a ciphertext value for every component key in the corresponding CompositePublicKey. For this mode, please see Composite-OR in section {{sec-comp-or-encr}}.

This process MAY be modified to accept the key material SS1, SS2, .., SSn as an input rather than generated as part of this process.


### Composite-OR encryption {#sec-comp-or-encr}

If the algorithm ID of the public key associated with this signature is id-composite-or-key then the encryptor MAY use only a subset of the component keys and therefore produce fewer ciphertexts than the number of recipient component keys.

Composite-OR encryption uses the same structures and algorithms as Composite, with the difference that the encryption process may emit a null instead of a ciphertext in step 2 for one or more component algorithms. A Composite-OR CompositeEncryptedKey MUST NOT be entirely null; it must contain at least one ciphertext.

The design intent of this mode is to support migration scenarios where an entity is encrypting for a peer which has been issued keys on algorithms that either the encryptor or the recipient do not (yet) support.

EDNOTE: Do we want to allow a Composite-OR with only a single ciphertext to produce non-composite EncryptedKey[RFC5652]? Advantages: bandwidth savings of an extra OID and some sequences with one element. Disadvantages: ambiguous whether a encrypted key is traditional or composite until you look at the corresponding key.

## Composite Decryption {#sec-comp-decr}

The following algorithm is used to decrypt a composite encrypted key values.

~~~
Input:
    E                  The encrypted value, a CompositeEncryptedKey
    
    K                  Private key for the n component encryption
                       algorithms, a CompositePurivateKey

Output:
     SS1, SS2, .., SSn Key material in the form of a set of shared secrets.

Ciphertext Decryption Procedure:

   1. Parse E into the component ciphertexts

      E1, E2, .., En := Desequence( E )
      K1, K2, .., Kn := Desequence( K )

    If Error during Desequencing, or the three sequences have
    different numbers of elements, or any of the private keys K1, K2, .., Kn or
    are composite with the OID id-alg-composite then output "Invalid ciphertext" and stop.

   2. Decrypt each component ciphertext individually, according to its
       algorithm specification.
       If any fail, then the entire decryption operation fails.

        for i := 1 to n
              if not (SSi := decrypt( Ki, Ei ), then
                output "Invalid ciphertext"

   3. Output SS1, SS2, .., SSn
~~~
{: artwork-name="alg-composite-decr"}

Security consideration: for timing-invariance, step 2 may need to process all provided ciphertexsts rather than short-circuiting with an error.

### Composite-OR decryption {#sec-comp-or-decr}

If the decryptor supports using their private key in the Composite-OR mode, then decryption of a null-valued ciphertext in step 2 is not considered an error. The process should emit a null value for the corresponding shared secret SSi, which MUST be treated as an empty string for the purposes of concatenation.

## Deriving a content encryption key


Given a set of shared secrets SS1, SS2, .., SSn as per {{sec-comp-encr}} and {{sec-comp-decr}}, they are to be combined into a content encryption key as:

~~~
Z := SS1
T := SS2 || .. || SSn
~~~

where || denotes concatenation. Z and T are then used as input to the key derivation scheme defined in :: TODO: CITE PROPERLY :: NIST SP 800-56Cr2 as the “hybrid” shared secret of the form Z′ = Z || T.


## Key encryption

EDNOTE: Copy from CMS (RFC 5652):

6.4.  Key-encryption Process

   The input to the key-encryption process -- the value supplied to the
   recipient's key-encryption algorithm -- is just the "value" of the
   content-encryption key.

   Any of the aforementioned key management techniques can be used for
   each recipient of the same encrypted content.

<!-- End of Composite Encryption Algorithm section -->

# In Practice {#sec-in-pract}

This section addresses practical issues of how this draft affects other protocols and standards.

<!-- End of In Practice section -->

# IANA Considerations {#sec-iana}
The ASN.1 module OID is TBD.  The id-alg-composite OID is to be assigned by IANA.  The authors suggest that IANA assign an OID on the id-pkix arc:

~~~
id-alg-composite OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) algorithms(6) composite(??) }
~~~

<!-- End of IANA Considerations section -->


# Security Considerations

## Policy for Deprecated and Acceptable Algorithms

Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.

In the composite model this is less obvious since a single public key, certificate, or signature may contain a mixture of deprecated and non-deprecated algorithms. Moreover, implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though neither algorithm is acceptable by itself.

Specifying a modified verification algorithm to handle these situations is beyond the scope of this draft, but could be desirable as the subject of an application profile document, or to be up to the discretion of implementers.

~~~
2. Check policy to see whether A1, A2, ..., An constitutes a valid
   combination of algorithms.

   if not checkPolicy(A1, A2, ..., An), then
     output "Invalid signature"
~~~

While intentionally not specified in this document, implementors should put careful thought into implementing a meaningfull policy mechinism within the context of their signature verification engines, for example only algorithms that provide similar security levels should be combined together.



<!-- End of Security Considerations section -->

# Appendices

## ASN.1 Module

EDNOTE: TODO: Update this from the signatures ASN.1.

~~~ asn.1

<CODE STARTS>

Composite-Signatures-2019
  { TBD }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
  PUBLIC-KEY, SIGNATURE-ALGORITHM
    FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-algorithmInformation-02(58) }

  SubjectPublicKeyInfo
    FROM PKIX1Explicit-2009
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-pkix1-explicit-02(51) }

  OneAsymmetricKey
    FROM AsymmetricKeyPackageModuleV1
      { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs-9(9) smime(16) modules(0)
        id-mod-asymmetricKeyPkgV1(50) } ;

--
-- Object Identifiers
--

id-alg-composite OBJECT IDENTIFIER ::= { TBD }

--
-- Public Key
--

pk-Composite PUBLIC-KEY ::= {
    IDENTIFIER id-alg-composite
    KEY CompositePublicKey
    PARAMS ARE absent
    PRIVATE-KEY CompositePrivateKey
}

CompositePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo

CompositePrivateKey ::= SEQUENCE SIZE (2..MAX) OF OneAsymmetricKey

--
-- Signature Algorithm
--

sa-CompositeSignature SIGNATURE-ALGORITHM ::= {
    IDENTIFIER id-alg-composite
    VALUE CompositeSignatureValue
    PARAMS TYPE CompositeParams ARE required
    PUBLIC-KEYS { pk-Composite }
    SMIME-CAPS { IDENTIFIED BY id-alg-composite } }

CompositeParams ::= SEQUENCE SIZE (2..MAX) OF AlgorithmIdentifier

CompositeSignatureValue ::= SEQUENCE SIZE (2..MAX) OF BIT STRING

END

<CODE ENDS>

~~~

## Intellectual Property Considerations

The following IPR Disclosure relates to this draft:

https://datatracker.ietf.org/ipr/3588/



# Contributors and Acknowledgements
This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:

John Gray (Entrust),
Serge Mister (Entrust),
Scott Fluhrer (Cisco Systems),
Panos Kampanakis (Cisco Systems),
Daniel Van Geest (ISARA), and
Tim Hollebeek (Digicert).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

## Making contributions

Additional contributions to this draft are weclome. Please see the working copy of this draft at, as well as open issues at:

https://github.com/EntrustCorporation/draft-ounsworth-pq-composite-encryption

<!-- End of Contributors section -->
