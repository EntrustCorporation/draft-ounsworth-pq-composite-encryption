<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Composite Encryption For Use In Internet PKI</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Composite Key Transport using Encryption primitives">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Algorithm Identifier">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Public key and key usage">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Algorithm parameters">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Encryption process">
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Decryption process">
<link href="#rfc.section.3" rel="Chapter" title="3 Composite Key Transport using Encryption and KEM primitives">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Algorithm Identifier">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Public key and key usage">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Algorithm parameters">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Encryption process">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Decryption process">
<link href="#rfc.section.4" rel="Chapter" title="4 Composite Key Exchange">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Algorithm Identifier">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Public key and key usage">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Algorithm parameters">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Encapsulation Process">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Decapsulation Process">
<link href="#rfc.section.5" rel="Chapter" title="5 Composite-OR variants">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Composite-OR subset encryption">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Composite-OR threshold encryption">
<link href="#rfc.section.6" rel="Chapter" title="6 In Practice">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Policy for Deprecated and Acceptable Algorithms">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Composite-OR modes">
<link href="#rfc.section.9" rel="Chapter" title="9 Appendices">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 ASN.1 Module">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Intellectual Property Considerations">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Making contributions">
<link href="#rfc.references" rel="Chapter" title="10 Normative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.40.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Ounsworth, M., Gray, J., and S. Mister" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ounsworth-pq-composite-encryption-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2021-06-06" />
  <meta name="dct.abstract" content="With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data. This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines three composite encryption modes. First, Composite Key Transport using Encryption primitives which encrypts a message (typically a content encryption key) for a recipient with a composite public key composed entirely of encryption keys by masking it with an XOR key which is split into key shares and each share encrypted under a different recipient public key. Second, Composite Key Transport using Encryption and KEM primitives is the generalization of the previous mode to support a mixture of encryption and KEM algorithms. Third, Composite Key Exchange is the most general and supports establishing a shared secret using any combination of encryption, KEM, and key exchange primitives where a master shared secret is generated using NIST SP 800-56Cr2. " />
  <meta name="description" content="With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data. This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines three composite encryption modes. First, Composite Key Transport using Encryption primitives which encrypts a message (typically a content encryption key) for a recipient with a composite public key composed entirely of encryption keys by masking it with an XOR key which is split into key shares and each share encrypted under a different recipient public key. Second, Composite Key Transport using Encryption and KEM primitives is the generalization of the previous mode to support a mixture of encryption and KEM algorithms. Third, Composite Key Exchange is the most general and supports establishing a shared secret using any combination of encryption, KEM, and key exchange primitives where a master shared secret is generated using NIST SP 800-56Cr2. " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">LAMPS</td>
<td class="right">M. Ounsworth</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">J. Gray</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">S. Mister</td>
</tr>
<tr>
<td class="left">Expires: December 8, 2021</td>
<td class="right">Entrust</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 06, 2021</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Composite Encryption For Use In Internet PKI<br />
  <span class="filename">draft-ounsworth-pq-composite-encryption-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data.</p>
<p>This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines three composite encryption modes. First, Composite Key Transport using Encryption primitives which encrypts a message (typically a content encryption key) for a recipient with a composite public key composed entirely of encryption keys by masking it with an XOR key which is split into key shares and each share encrypted under a different recipient public key. Second, Composite Key Transport using Encryption and KEM primitives is the generalization of the previous mode to support a mixture of encryption and KEM algorithms. Third, Composite Key Exchange is the most general and supports establishing a shared secret using any combination of encryption, KEM, and key exchange primitives where a master shared secret is generated using NIST SP 800-56Cr2.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 8, 2021.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2021 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Composite Key Transport using Encryption primitives</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Algorithm Identifier</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Public key and key usage</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Algorithm parameters</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Encryption process</a>
</li>
<li>2.5.   <a href="#rfc.section.2.5">Decryption process</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Composite Key Transport using Encryption and KEM primitives</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Algorithm Identifier</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Public key and key usage</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Algorithm parameters</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Encryption process</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Decryption process</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Composite Key Exchange</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Algorithm Identifier</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Public key and key usage</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Algorithm parameters</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Encapsulation Process</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Decapsulation Process</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Composite-OR variants</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Composite-OR subset encryption</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Composite-OR threshold encryption</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">In Practice</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Policy for Deprecated and Acceptable Algorithms</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Composite-OR modes</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Appendices</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">ASN.1 Module</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Intellectual Property Considerations</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Making contributions</a>
</li>
</ul><li>10.   <a href="#rfc.references">Normative References</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#sec-intro" id="sec-intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, but we will also not fully trust their post-quantum replacements until they have had sufficient scrutiny. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.</p>
<p id="rfc.section.1.p.2">The deployment of composite public keys and composite encryption using post-quantum algorithms will face two challenges:</p>
<p></p>

<ul>
<li>Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.</li>
<li>Backwards compatibility: During the transition period, post-quantum algorithms will not be supported by all clients.</li>
</ul>
<p id="rfc.section.1.p.4">This document provides mechanisms to address algorithm strength uncertainty by buliding on ~~ reference draft-ounsworth-pq-composite-pubkeys ~~ by providing formats for both wrapping a content encryption key using multiple public key encryption mechanisms, or performing key exchange using a combination of encryption, Key encapsulation, and key exchange primitives. The issue of backwards compatibility is is addressed with Composite-OR encryption modes defined in <a href="#sec-comp-or" class="xref">Section 5</a>.</p>
<p id="rfc.section.1.p.5">This document is intended for general applicability anywhere that content encryption or key exchange is used.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#sec-terminology" id="sec-terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a>  <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.1.p.2">The following terms are used in this document:</p>
<p id="rfc.section.1.1.p.3">ALGORITHM: An information object class for identifying the type of cryptographic operation to be performed. This document is primarily concerned with algorithms for producing encryption keys.</p>
<p id="rfc.section.1.1.p.4">BER: Basic Encoding Rules (BER) as defined in <a href="#X.690" class="xref">[X.690]</a>.</p>
<p id="rfc.section.1.1.p.5">COMPONENT ALGORITHM: A single basic algorithm which is contained within a composite algorithm.</p>
<p id="rfc.section.1.1.p.6">COMPOSITE ALGORITHM: An algorithm which is a sequence of one or more component algorithms..</p>
<p id="rfc.section.1.1.p.7">DER: Distinguished Encoding Rules as defined in <a href="#X.690" class="xref">[X.690]</a>.</p>
<p id="rfc.section.1.1.p.8">KEY SHARE: A type of shared secret where a key splitting scheme is used to distribute multiple secrets over different channels such that some or all of the secrets must be re-combined to recover the primary shared secret.</p>
<p id="rfc.section.1.1.p.9">PUBLIC / PRIVATE KEY: The public and private portion of an asymmetric cryptographic key, making no assumptions about which algorithm.</p>
<p id="rfc.section.1.1.p.10">PRIMITIVE PUBLIC KEY / SIGNATURE: A public key or signature object of a non-composite algorithm type.</p>
<p id="rfc.section.1.1.p.11">SIGNATURE: A digital cryptographic signature, making no assumptions about which algorithm.</p>
<p id="rfc.section.1.1.p.12">SECRET or SHARED SECRET: Cryptographic material established between two parties.  May be generated by one party and send encrypted to the other, or may be the output of an exchange of public information between two or more parties that generates a unique shared value for all involved parties.</p>
<p id="rfc.section.1.1.p.13">KEY DERIVATION FUNCTION: A function used to derive secure secret keys using shared secrets, hashing and other cryptographic primitives.</p>
<p id="rfc.section.1.1.p.14">COMPOSITE ENCRYPTION KEY: A structure that contains a sequence of content encryption keys, or secrets used to derive a content encryption keys.</p>
<p id="rfc.section.1.1.p.15">TRIVIAL SECRET SHARING A method to securely share a secret among two or more parties where all parties need to combine their intermediate secret to re-create the secret.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#sec-com-key-trans_encr" id="sec-com-key-trans_encr">Composite Key Transport using Encryption primitives</a>
</h1>
<p id="rfc.section.2.p.1">In this composite encryption mode, a message to be encrypted is provided by the calling application.  This message to be encrypted is assumed without loss of generality to be a symmetric content encryption key (CEK) which is assumed to have a size less maximum message size of the chosen encryption algorithms.</p>
<p id="rfc.section.2.p.2">This mode is compatible with protocols requiring a key transport primitive, such as CMS' KeyTransRecipientInfo <a href="#RFC5652" class="xref">[RFC5652]</a>.</p>
<p id="rfc.section.2.p.3">Composite Key Transport using Encryption primitives uses a trivial XOR key-sharing scheme, as defined in <a href="#sec-com-key-trans_encr_process" class="xref">Section 2.4</a> to transport n secrets called key shares, where n is the number of recipient component public keys, and each share is encrypted under a different recipient component public key. The trivial XOR key-sharing scheme requires the recipient to use all component private keys in order to recover the content encryption key. Note that it would be possible to use an "n of m" or "threshold" secret sharing scheme if it was desired for the recipient to be able to complete the key transport using a subset of their private keys, but that mechanism is not defined in this document; see section <a href="#sec-comp-or-thresh-encr" class="xref">Section 5.2</a> for further discussion.</p>
<p id="rfc.section.2.p.4">EDNOTE: we have not been able to find a reference and security analysis for the trivial XOR key-sharing scheme. This may need review by CFRG. We could re-frame this process as "a one-time pad with n-1 one-time pad keys, which we transport using the recipients public keys", then this could leverage one-time pad security analysis.</p>
<p id="rfc.section.2.p.5">Composite encryption uses the following structure:</p>
<p id="rfc.section.2.p.6">EDNOTE:  Should a different composite OID be used to determine the type of composite encryption (Key Transport or Key Agreement?).  Probably not because the desired key usage will be handled in the protocols that uses this privitive.</p>
<pre>
CompositeEncryptedKey ::= EncryptedKey{ SEQUENCE SIZE (2..Max)  OF OCTET STRING}
</pre>
<p id="rfc.section.2.p.7">EDNOTE: This ASN.1 probably does not compile. The intent is that this fits into any EncryptedKey field, but defines some structure within the existing EncryptedKey ::= OCTET STRING, but I'm not sure exactly how to specify that.</p>
<p id="rfc.section.2.p.8">Where each OCTET STRING within the SEQUENCE contains an encrypted key share encrypted under one of the recipient component public keys. The CompositeEncryptedKey MUST list encrypted values in the same order as the recipient public key's component keys.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#algorithm-identifier" id="algorithm-identifier">Algorithm Identifier</a>
</h1>
<p id="rfc.section.2.1.p.1">The id-alg-composite-encryption object identifier MUST be used to identify the usage of this mode</p>
<pre>
id-alg-composite-encryption OBJECT IDENTIFIER ::= {
    iso(1)  identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) OpenCA(18227) Algorithms(2) id-alg-composite-encryption(1) }
</pre>
<p id="rfc.section.2.1.p.2">EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see <a href="#sec-iana" class="xref">Section 7</a>.</p>
<p id="rfc.section.2.1.p.3">EDNOTE: I'm inventing OIDs on the OpenCA arc; need to put these in the Entrust arc.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#public-key-and-key-usage" id="public-key-and-key-usage">Public key and key usage</a>
</h1>
<p id="rfc.section.2.2.p.1">The recipient MUST have a composite public key which supports key transport operations. Where the recipient public key has an associated keyUsage as specified in <a href="#RFC5280" class="xref">[RFC5280]</a>, it MUST have keyUsage: keyEncipherment. In other words, the mechanism specified in this section applies only if all of the recipient's public keys are encryption algorithms.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#sec-com-key-trans_encr-params" id="sec-com-key-trans_encr-params">Algorithm parameters</a>
</h1>
<p id="rfc.section.2.3.p.1">The composite key transport using encryption mode does not require additional parameters, and therefore any associated Params are ABSENT.</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#sec-com-key-trans_encr_process" id="sec-com-key-trans_encr_process">Encryption process</a>
</h1>
<p id="rfc.section.2.4.p.1">The process for performing Composite Key Transport using Encryption primitives is as follows:</p>
<p id="rfc.section.2.4.p.2">The first n-1 key shares are random bit strings of the same length as the content encryption key.  The final key share is computed by XOR'ing the content encryption key with each of n-1 previous key shares.</p>
<pre>
Input:
     n                  The number of recipient component public keys
     P1, P2, .., Pn     Recipient component public keys
     CEK                The Content Encryption Key
     SIZE               The size of the Content Encryption Key in bits

Output:
     E1, E2, .., En     EncryptedKey values corresponding to each recipient
                        component public key

Intermediate values:
     S1, S2, .., Sn     Key shares to be encapsulated by each 
                        component algorithm

Generation Procedure:
   1. Generate a set of n-1 key shares of the same length as the
      content encryption key
        for i := 1 to n-1
          Si := random_bits(SIZE)

   2. To generate key share Sn, compute the following
        Sn = CEK
        for i := 1 to n-1
          Sn = Sn XOR Si

   3. Encrypt each key share under a recipient public key
        for i := 1 to n
          Ei := encrypt(Si, Pi)

   4. Output E1, E2, .., En
</pre>
<p id="rfc.section.2.4.p.3">Where <samp>random_bits(SIZE)</samp> is a cryptographically-secure random bit generator outputting SIZE bits.</p>
<h1 id="rfc.section.2.5">
<a href="#rfc.section.2.5">2.5.</a> <a href="#sec-com-key-trans_decr_process" id="sec-com-key-trans_decr_process">Decryption process</a>
</h1>
<p id="rfc.section.2.5.p.1">To obtain the content-encryption key from a CompositeEncryptedKey, each component algorithm MUST be used to decrypt the set of key shares.  The key shares are then XOR'ed together to recover the content encryption key.</p>
<pre>
Input:
     n                  The number of recipient component public keys

     SK1, SK2, .., SKn  Recipient component secret keys
     
     E1, E2, .., En     EncryptedKey values corresponding to each recipient
                        component public key


Intermediate values:
     S1, S2, .., Sn     Key shares to be decapsulated by each 
                        component algorithm

Output:
     CEK  The Content Encryption Key


Generation Procedure:
   1. Recover each key share
        for i := 1 to n
          Si := decrypt(Ei, SKi)

   2. Recover the CEK;
      For each intermediate shared-secret
        CEK = S1
        for i := 2 to n
           CEK = CEK XOR Si

   3. Output CEK
</pre>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#sec-com-key-trans_kem" id="sec-com-key-trans_kem">Composite Key Transport using Encryption and KEM primitives</a>
</h1>
<p id="rfc.section.3.p.1">This composite encryption mode is the generalization of the mode defined in <a href="#sec-com-key-trans_encr" class="xref">Section 2</a> to support a composite recipient public key which MAY contain an arbitrary mixture of encryption and key encapsulation mechanism (KEM) component algorithms.</p>
<p id="rfc.section.3.p.2">This mode is compatible with protocols requiring a key transport primitive, such as CMS' KeyTransRecipientInfo <a href="#RFC5652" class="xref">[RFC5652]</a>.</p>
<p id="rfc.section.3.p.3">Security consideration: for a recipient composite public key to be applicable to this mode, all component KEMs SHOULD produce a shared secret whose bits are independent and uniformly distributed (aka "uniformly IID" or "uniformly random" or "full entropy") and therefore the shared secret is safe to use direcly as a symmetric key. If a recipient public key contains component KEMs which are not know to have this property, then implementors SHOULD use the more general mode described in <a href="#sec-com-key-exchange" class="xref">Section 4</a> which incorporates the use of a key derivation function.</p>
<p id="rfc.section.3.p.4">EDNOTE: also put this in the Security considerations section.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#algorithm-identifier-1" id="algorithm-identifier-1">Algorithm Identifier</a>
</h1>
<p id="rfc.section.3.1.p.1">The id-alg-composite-kem object identifier MUST be used to identify the usage of this mode</p>
<pre>
id-alg-composite-kem OBJECT IDENTIFIER ::= {
    iso(1)  identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) OpenCA(18227) Algorithms(2) id-alg-composite-kem(1) }
</pre>
<p id="rfc.section.3.1.p.2">EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see <a href="#sec-iana" class="xref">Section 7</a>.</p>
<p id="rfc.section.3.1.p.3">EDNOTE: I'm inventing OIDs on the OpenCA arc; need to put these in the Entrust arc.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#public-key-and-key-usage-1" id="public-key-and-key-usage-1">Public key and key usage</a>
</h1>
<p id="rfc.section.3.2.p.1">The recipient MUST have a composite public key which supports key transport or key encapsulation operations. Where the recipient public key has an associated keyUsage as specified in <a href="#RFC5280" class="xref">[RFC5280]</a>, it MUST have keyUsage: keyEncipherment. In other words, the mechanism specified in this section applies only if all of the recipient's public keys are encryption or KEM algorithms.</p>
<p id="rfc.section.3.2.p.2">In addition, for a recipient composite public key to be applicable to this mode, all component KEMs MUST be capable of producing a shared secret of SIZE bits, where SIZE is the length in bits of the content encryption key (CEK) to be transported. This is assumed for the remainer of this section.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#sec-com-key-trans_kem-params" id="sec-com-key-trans_kem-params">Algorithm parameters</a>
</h1>
<p id="rfc.section.3.3.p.1">The composite key transport using encryption and KEM mode does not require additional parameters, and therefore any associated Params are ABSENT.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#encryption-process" id="encryption-process">Encryption process</a>
</h1>
<p id="rfc.section.3.4.p.1">Given these conditions are met, the encryption process defined in <a href="#sec-com-key-trans_encr_process" class="xref">Section 2.4</a> is modified as follows:</p>
<pre>
Generation Procedure:
   1. Generate a set of key shares of the same length as the
      content encryption key and encapsulate or encrypt them
      under a recipient public key.      
        for i := 1 to n-1
          if P1 is of type KEM:
            Si,Ei := encaps(P1)
          else:
            Si := random_bits(SIZE)
            Ei := encrypt(Si, Pi)

   2. To generate key share Sn, compute the following
        Sn = CEK
        for i := 1 to n-1
          Sn = Sn XOR Si

   3. Encrypt key share Sn under recipient public key Pn
        En := encrypt(Sn, Pn)

   4. Output E1, E2, .., En

</pre>
<p id="rfc.section.3.4.p.2">Where <samp>random_bits(SIZE)</samp> is a cryptographically-secure random bit generator outputting SIZE bits.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#decryption-process" id="decryption-process">Decryption process</a>
</h1>
<p id="rfc.section.3.5.p.1">The decryption process defined in <a href="#sec-com-key-trans_decr_process" class="xref">Section 2.5</a> applies directly where <samp>decrypt()</samp> is substituted for <samp>decaps()</samp> when the underlying primitive is a KEM.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sec-com-key-exchange" id="sec-com-key-exchange">Composite Key Exchange</a>
</h1>
<p id="rfc.section.4.p.1">This mode is the most general in that it supports a composite recipient public key which MAY contain an arbitrary mixture of encryption, key encapsulation mechanism (KEM), and key agreement component algorithms. Due to the nature of key agreement algorithms, this mode cannot take a content encryption key as input, but instead generates a master shared secret as an output. As such, the nomenclature in this mode differs from the modes above.</p>
<p id="rfc.section.4.p.2">This mode is compatible with protocols requiring a key agreement primitive, such as CMS' KeyAgreeRecipientInfo <a href="#RFC5652" class="xref">[RFC5652]</a>.</p>
<p id="rfc.section.4.p.3">Composite key exchange uses the underlying primitive to either encrypt for, encapsulate, or interactively do key agreement with each of the recipient's public keys, then all shared secrets are concatenated together and a KDF is applies as prescribed by NIST SP-800 56Cr2 &lt;TODO: cite properly&gt;.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#algorithm-identifier-2" id="algorithm-identifier-2">Algorithm Identifier</a>
</h1>
<p id="rfc.section.4.1.p.1">The id-alg-composite-keyex object identifier MUST be used to identify the usage of this mode</p>
<pre>
id-alg-composite-keyex OBJECT IDENTIFIER ::= {
    iso(1)  identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) OpenCA(18227) Algorithms(2) id-alg-composite-keyex(1) }
</pre>
<p id="rfc.section.4.1.p.2">EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see <a href="#sec-iana" class="xref">Section 7</a>.</p>
<p id="rfc.section.4.1.p.3">EDNOTE: I'm inventing OIDs on the OpenCA arc; need to put these in the Entrust arc.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#public-key-and-key-usage-2" id="public-key-and-key-usage-2">Public key and key usage</a>
</h1>
<p id="rfc.section.4.2.p.1">The recipient MUST have a composite public key which supports key transport, key encapsulation, or key exchange operations. Where the recipient public key has an associated keyUsage as specified in <a href="#RFC5280" class="xref">[RFC5280]</a>, it MUST have keyUsage: keyEncipherment, keyAgreement. This mode is the most general and places the fewest restrictions on the recipient public key.</p>
<p id="rfc.section.4.2.p.2">EDNOTE: I think this violates our public key draft where we say that the public key's KU MUST apply to all components. ... we did not want mixing of signatures and encryption keys, but I think in this case we do want to allow mixing of keyEncipherment and keyExchange keys. Not sure how to fix that.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#sec-com-key-exchange-params" id="sec-com-key-exchange-params">Algorithm parameters</a>
</h1>
<p id="rfc.section.4.3.p.1">The composite key exchange mode requires additional parameters to specify the KDF used to combine key shares into a master shared secret.</p>
<p id="rfc.section.4.3.p.2">Params ::= KeyDerivationAlgorithmIdentifier</p>
<p id="rfc.section.4.3.p.3">The KeyDerivationAlgorithmIdentifier type is specified in <a href="#RFC3211" class="xref">[RFC3211]</a> and <a href="#RFC5652" class="xref">[RFC5652]</a>. The KeyDerivationAlgorithmIdentifier definition is repeated here for completeness.</p>
<pre>
KeyDerivationAlgorithmIdentifier ::= AlgorithmIdentifier
</pre>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#encapsulation-process" id="encapsulation-process">Encapsulation Process</a>
</h1>
<p id="rfc.section.4.4.p.1">Composite key exchange uses the underlying primitive to either encrypt for, encapsulate, or interactively do key agreement with each of the recipient's public keys, then all shared secrets are concatenated together and a KDF is applies as prescribed by NIST SP-800 56Cr2 &lt;TODO: cite properly&gt;.</p>
<pre>
Input:
     P1, P2, .., Pn     Public keys for the n component encryption
                        algorithms, a CompositePublicKey
    
    SIZE                The size, in bits, for shared secrets to be combined by both 
                        parties into a content encryption key. This value SHOULD correspond
                        to the size of the content encryption key.

    KDF                 A key derivation function

Output:
     E1, E2, .., En     EncryptedKey values corresponding to each recipient
                        component public key

     M                  Master shared secret
    

Ciphertext Generation Procedure:
   1. Generate a set of key shares of the same length as the
      content encryption key
        for i := 1 to n-1
          if P1 is of type KEM or keyExchange:
            Si,Ei := encaps(P1)
          else:
            Si := random_bits(SIZE)

        for i := 1 to n-1
          if P1 is of type KEM or KeyAgree:
            Si,Ei := encaps(P1)
          else:
            Si := random_bits(SIZE)
            Ei := encrypt(Si, Pi)

   2. Generate Z via concatenation
        Z = S1 || S2 || .. || Sn

   3. Generate the master shared secret via a KDF
        M = KDF(Z)

  4. Output M
     Output E1, E2, .., En

</pre>
<p id="rfc.section.4.4.p.2">In cases where KDF is extensible output function, the length of M must be carried in the KeyDerivationAlgorithmIdentifier defined in <a href="#sec-com-key-exchange-params" class="xref">Section 4.3</a>.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#decapsulation-process" id="decapsulation-process">Decapsulation Process</a>
</h1>
<pre>
Input:
     n                  The number of recipient component public keys

     SK1, SK2, .., SKn  Recipient component secret keys

     E1, E2, .., En     EncryptedKey values corresponding to each recipient
                        component public key

    KDF                 A key derivation function


Intermediate values:
     S1, S2, .., Sn     Key shares to be encapsulated by each 
                        component algorithm

Output:
     M                  Master shared secret
    

Ciphertext Generation Procedure:
   1. Recover each key share
        for i := 1 to n
          Si := decrypt_or_decaps(Ei, SKi)

   2. Generate Z via concatenation
        Z = S1 || S2 || .. || Sn

   3. Generate the master shared secret via a KDF
        M = KDF(Z)

  4. Output M
</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sec-comp-or" id="sec-comp-or">Composite-OR variants</a>
</h1>
<p id="rfc.section.5.p.1">In order to ease migration, two variants of the key transport encryption modes defined in <a href="#sec-com-key-trans_encr" class="xref">Section 2</a>} and <a href="#sec-com-key-trans_kem" class="xref">Section 3</a> are defined that allow the sender to construct the cipher text in such a way that either the sender or the recipient can use a subset of the recipient's component algorithms.</p>
<p id="rfc.section.5.p.2">Composite-OR subset encryption is intended for migration scenarios where the sender does not support all of the recipient's component algorithms. This variant allows the sender to emit a null ciphertext for unsupported component algorithms.</p>
<p id="rfc.section.5.p.3">Composite-OR threshold encryption is intended for migration scenarios where the sender supports all of the recipient's component algorithms, but the recipient may not. This variant allows the sender to use an "n of m" or threshold secret sharing scheme, such as Shamir's secret sharing, instead of the XOR secret sharing scheme used above.</p>
<p id="rfc.section.5.p.4">The Composite-OR variants MAY be used if the algorithm ID of the recipient public key is id-composite-or-key. Those variants MUST NOT be used if the algorithm ID of the recipient public key is id-composite-key.</p>
<p id="rfc.section.5.p.5">Security consideration: Composite-OR eases migration at the expense of security. In the subset encryption variant the security of the composite ciphertext is weakened to the algorithms used. In the threshold encryption variant with a threshold of n key shares, the security of the ciphertext is to be evaluated as if the recipient's weakest n algorithms were used.</p>
<p id="rfc.section.5.p.6">EDNOTE: at present these are not fully specified; if the IETF community thinks they are worth standardizing, then they will need their own OIDs, and the threshold scheme will need params.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec-comp-or-sub-encr" id="sec-comp-or-sub-encr">Composite-OR subset encryption</a>
</h1>
<p id="rfc.section.5.1.p.1">If the algorithm ID of the recipient public key is id-composite-or-key then the encryptor MAY use either key trasnport mode (<a href="#sec-com-key-trans_encr" class="xref">Section 2</a>} and <a href="#sec-com-key-trans_kem" class="xref">Section 3</a>) with only a subset of the component keys and therefore produce fewer ciphertexts than the number of recipient component keys.</p>
<p id="rfc.section.5.1.p.2">Composite-OR subset encryption uses the same structures and processes as <a href="#sec-com-key-trans_encr" class="xref">Section 2</a>} or <a href="#sec-com-key-trans_kem" class="xref">Section 3</a>, with the difference that the encryption process may emit a null instead of a ciphertext one or more component algorithms and the corresponding shared secret is taken to be 0 for the purposes of the XOR computation. A Composite-OR CompositeEncryptedKey MUST NOT be entirely null; it must contain at least one ciphertext.</p>
<p id="rfc.section.5.1.p.3">The design intent of this mode is to support migration scenarios where an entity is encrypting for a peer which has been issued keys on algorithms that either the encryptor or the recipient do not (yet) support.</p>
<p id="rfc.section.5.1.p.4">EDNOTE: Do we want to allow a Composite-OR with only a single ciphertext to produce non-composite EncryptedKey<a href="#RFC5652" class="xref">[RFC5652]</a>? Advantages: bandwidth savings of an extra OID and some sequences with one element. Disadvantages: ambiguous whether a encrypted key is traditional or composite until you look at the corresponding key.</p>
<p id="rfc.section.5.1.p.5">EDNOTE:  I do not think we get a lot of value with Composite-OR with a single key because it is essentially just a wrapper around the regular algorithm.  I can see use for systems that recognize the composite structure which may not yet support all the component encryption algorithms, so a composite with algorithms that are not yet understood could be pushed out and one or more of the components could get used.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#sec-comp-or-thresh-encr" id="sec-comp-or-thresh-encr">Composite-OR threshold encryption</a>
</h1>
<p id="rfc.section.5.2.p.1">If the algorithm ID of the recipient public key is id-composite-or-key then the encryptor MAY use either key trasnport mode (<a href="#sec-com-key-trans_encr" class="xref">Section 2</a>} and <a href="#sec-com-key-trans_kem" class="xref">Section 3</a>) with only a subset of the component keys and therefore produce fewer ciphertexts than the number of recipient component keys.</p>
<p id="rfc.section.5.2.p.2">Composite-OR subset encryption uses the same structures and processes as <a href="#sec-com-key-trans_encr" class="xref">Section 2</a>} or <a href="#sec-com-key-trans_kem" class="xref">Section 3</a>, with the difference that the encryption process may emit a null instead of a ciphertext one or more component algorithms. A Composite-OR CompositeEncryptedKey MUST NOT be entirely null; it must contain at least one ciphertext.</p>
<p id="rfc.section.5.2.p.3">The design intent of this mode is to support migration scenarios where an entity is encrypting for a peer which has been issued keys on algorithms that either the encryptor or the recipient do not (yet) support.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec-in-pract" id="sec-in-pract">In Practice</a>
</h1>
<p id="rfc.section.6.p.1">This section addresses practical issues of how this draft affects other protocols and standards.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sec-iana" id="sec-iana">IANA Considerations</a>
</h1>
<p id="rfc.section.7.p.1">The ASN.1 module OID is TBD.  The id-alg-composite OID is to be assigned by IANA.  The authors suggest that IANA assign an OID on the id-pkix arc:</p>
<pre>
id-alg-composite OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) algorithms(6) composite(??) }
</pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#policy-for-deprecated-and-acceptable-algorithms" id="policy-for-deprecated-and-acceptable-algorithms">Policy for Deprecated and Acceptable Algorithms</a>
</h1>
<p id="rfc.section.8.1.p.1">Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.</p>
<p id="rfc.section.8.1.p.2">In the composite model this is less obvious since a single public key, certificate, or signature may contain a mixture of deprecated and non-deprecated algorithms. Moreover, implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though neither algorithm is acceptable by itself.</p>
<p id="rfc.section.8.1.p.3">Specifying a modified verification algorithm to handle these situations is beyond the scope of this draft, but could be desirable as the subject of an application profile document, or to be up to the discretion of implementers.</p>
<pre>
2. Check policy to see whether A1, A2, ..., An constitutes a valid
   combination of algorithms.

   if not checkPolicy(A1, A2, ..., An), then
     output "Invalid signature"
</pre>
<p id="rfc.section.8.1.p.4">While intentionally not specified in this document, implementors should put careful thought into implementing a meaningfull policy mechinism within the context of their signature verification engines, for example only algorithms that provide similar security levels should be combined together.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#composite-or-modes" id="composite-or-modes">Composite-OR modes</a>
</h1>
<p id="rfc.section.8.2.p.1">Composite-OR eases migration at the expense of security. In the subset encryption variant the security of the composite ciphertext is weakened to the algorithms used. In the threshold encryption variant with a threshold of n key shares, the security of the ciphertext is to be evaluated as if the recipient's weakest n algorithms were used.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#appendices" id="appendices">Appendices</a>
</h1>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#asn1-module" id="asn1-module">ASN.1 Module</a>
</h1>
<p id="rfc.section.9.1.p.1">~~ TODO ~~</p>
<p id="rfc.section.9.1.p.2">~~~</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#intellectual-property-considerations" id="intellectual-property-considerations">Intellectual Property Considerations</a>
</h1>
<p id="rfc.section.9.2.p.1">The following IPR Disclosure relates to this draft:</p>
<p id="rfc.section.9.2.p.2">https://datatracker.ietf.org/ipr/3588/</p>
<p id="rfc.section.9.2.p.3">We are grateful to all, including any contributors who may have been inadvertently omitted from this list.</p>
<p id="rfc.section.9.2.p.4">This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those documents.  "Copying always makes things easier and less error prone" - <a href="#RFC8411" class="xref">[RFC8411]</a>.</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#making-contributions" id="making-contributions">Making contributions</a>
</h1>
<p id="rfc.section.9.3.p.1">Additional contributions to this draft are weclome. Please see the working copy of this draft at, as well as open issues at:</p>
<p id="rfc.section.9.3.p.2">https://github.com/EntrustCorporation/draft-ounsworth-pq-composite-encryption</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2986">[RFC2986]</b></td>
<td class="top">
<a>Nystrom, M.</a> and <a>B. Kaliski</a>, "<a href="https://tools.ietf.org/html/rfc2986">PKCS #10: Certification Request Syntax Specification Version 1.7</a>", RFC 2986, DOI 10.17487/RFC2986, November 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3211">[RFC3211]</b></td>
<td class="top">
<a>Gutmann, P.</a>, "<a href="https://tools.ietf.org/html/rfc3211">Password-based Encryption for CMS</a>", RFC 3211, DOI 10.17487/RFC3211, December 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4210">[RFC4210]</b></td>
<td class="top">
<a>Adams, C.</a>, <a>Farrell, S.</a>, <a>Kause, T.</a> and <a>T. Mononen</a>, "<a href="https://tools.ietf.org/html/rfc4210">Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)</a>", RFC 4210, DOI 10.17487/RFC4210, September 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5652">[RFC5652]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="https://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8411">[RFC8411]</b></td>
<td class="top">
<a>Schaad, J.</a> and <a>R. Andrews</a>, "<a href="https://tools.ietf.org/html/rfc8411">IANA Registration for the Cryptographic Algorithm Object Identifier Range</a>", RFC 8411, DOI 10.17487/RFC8411, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="X.690">[X.690]</b></td>
<td class="top">
<a>ITU-T</a>, "<a>Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO/IEC 8825-1:2015, November 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Ounsworth</span> 
	  <span class="n hidden">
		<span class="family-name">Ounsworth</span>
	  </span>
	</span>
	<span class="org vcardline">Entrust Limited</span>
	<span class="adr">
	  <span class="vcardline">1000 Innovation Drive</span>

	  <span class="vcardline">
		<span class="locality">Ottawa, Ontario</span>,  
		<span class="region"></span>
		<span class="code">K2K 1E3</span>
	  </span>
	  <span class="country-name vcardline">Canada</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mike.ounsworth@entrust.com">mike.ounsworth@entrust.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Gray</span> 
	  <span class="n hidden">
		<span class="family-name">Gray</span>
	  </span>
	</span>
	<span class="org vcardline">Enrust Limited</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:john.gray@entrust.com">john.gray@entrust.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Serge Mister</span> 
	  <span class="n hidden">
		<span class="family-name">Mister</span>
	  </span>
	</span>
	<span class="org vcardline">Enrust Limited</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:serge.mister@entrust.com">serge.mister@entrust.com</a></span>

  </address>
</div>

</body>
</html>
