<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Composite Encryption For Use In Internet PKI</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Composite Structures">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Algorithm Identifier">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Composite Keys">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Key Usage Bits">
<link href="#rfc.section.3" rel="Chapter" title="3 Composite Content Key Encryption Using Key Transport">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Composite Encryption given a content-encryption key">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Content Encryption Key Sharing among n component algorithms">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Composite Encryption without secret key sharing">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Composite Content Key Encryption using Key Transport with key derivation">
<link href="#rfc.section.4" rel="Chapter" title="4 Composite Content Key Encryption using Key Agreement">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Encoding Rules">
<link href="#rfc.section.5" rel="Chapter" title="5 Composite encryption and decryption Processes">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Generation of CompositeEncryptedKey using Key Transport">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Composite encryption using Key Agree">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Composite-OR encryption">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Composite decryption using Key Agree">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Composite-OR decryption">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Deriving a content encryption key">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Key Derivation">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Key encryption">
<link href="#rfc.section.6" rel="Chapter" title="6 In Practice">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Policy for Deprecated and Acceptable Algorithms">
<link href="#rfc.section.9" rel="Chapter" title="9 Appendices">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 ASN.1 Module">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Intellectual Property Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Contributors and Acknowledgements">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Making contributions">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.40.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Ounsworth (Editor), M. and J. Gray" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ounsworth-pq-composite-encryption-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2021-04-19" />
  <meta name="dct.abstract" content="With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data. This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines id-composite-encryption which encrypts for a recipient with a composite public key by generating a shared secret for each of the recipient&#x27;s component public keys and combining them into a single content encryption key using NIST SP 800-56Cr2. " />
  <meta name="description" content="With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data. This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines id-composite-encryption which encrypts for a recipient with a composite public key by generating a shared secret for each of the recipient&#x27;s component public keys and combining them into a single content encryption key using NIST SP 800-56Cr2. " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">LAMPS</td>
<td class="right">M. Ounsworth (Editor)</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">J. Gray</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Entrust</td>
</tr>
<tr>
<td class="left">Expires: October 21, 2021</td>
<td class="right">April 19, 2021</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Composite Encryption For Use In Internet PKI<br />
  <span class="filename">draft-ounsworth-pq-composite-encryption-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite encryption data.</p>
<p>This document defines a content encryption process following the hybrid model as described in the NIST Post-Quantum Crypto FAQ. This draft defines id-composite-encryption which encrypts for a recipient with a composite public key by generating a shared secret for each of the recipient's component public keys and combining them into a single content encryption key using NIST SP 800-56Cr2.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 21, 2021.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2021 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Composite Structures</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Algorithm Identifier</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Composite Keys</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Key Usage Bits</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Composite Content Key Encryption Using Key Transport</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Composite Encryption given a content-encryption key</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Content Encryption Key Sharing among n component algorithms</a>
</li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Composite Encryption without secret key sharing</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Composite Content Key Encryption using Key Transport with key derivation</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Composite Content Key Encryption using Key Agreement</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Encoding Rules</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Composite encryption and decryption Processes</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Generation of CompositeEncryptedKey using Key Transport</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Composite encryption using Key Agree</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Composite-OR encryption</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Composite decryption using Key Agree</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Composite-OR decryption</a>
</li>
</ul><li>5.4.   <a href="#rfc.section.5.4">Deriving a content encryption key</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Key Derivation</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Key encryption</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">In Practice</a>
</li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Policy for Deprecated and Acceptable Algorithms</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Appendices</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">ASN.1 Module</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Intellectual Property Considerations</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Contributors and Acknowledgements</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Making contributions</a>
</li>
</ul><li>11.   <a href="#rfc.references">References</a>
</li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#sec-intro" id="sec-intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, but we will also not fully trust their post-quantum replacements until they have had sufficient scrutiny. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.</p>
<p id="rfc.section.1.p.2">The deployment of composite public keys and composite encryption using post-quantum algorithms will face two challenges:</p>
<p></p>

<ul>
<li>Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.</li>
<li>Backwards compatibility: During the transition period, post-quantum algorithms will not be supported by all clients.</li>
</ul>
<p id="rfc.section.1.p.4">This document provides a mechanism to address algorithm strength uncertainty by buliding on ~~ reference draft-ounsworth-pq-composite-pubkeys ~~ by providing formats for wrapping a content encryption key using multiple public key encryption mechanisms into existing fields. The issue of backwards compatibility is left open to be addressed in separate draft(s).</p>
<p id="rfc.section.1.p.5">This document is intended for general applicability anywhere that content encryption is used.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#sec-terminology" id="sec-terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a>  <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.1.p.2">The following terms are used in this document:</p>
<p id="rfc.section.1.1.p.3">ALGORITHM: An information object class for identifying the type of cryptographic operation to be performed. This document is primarily concerned with algorithms for producing encryption keys.</p>
<p id="rfc.section.1.1.p.4">BER: Basic Encoding Rules (BER) as defined in <a href="#X.690" class="xref">[X.690]</a>.</p>
<p id="rfc.section.1.1.p.5">COMPONENT ALGORITHM: A single basic algorithm which is contained within a composite algorithm.</p>
<p id="rfc.section.1.1.p.6">COMPOSITE ALGORITHM: An algorithm which is a sequence of one or more component algorithms, as defined in <a href="#sec-composite-structs" class="xref">Section 2</a>.</p>
<p id="rfc.section.1.1.p.7">DER: Distinguished Encoding Rules as defined in <a href="#X.690" class="xref">[X.690]</a>.</p>
<p id="rfc.section.1.1.p.8">PUBLIC / PRIVATE KEY: The public and private portion of an asymmetric cryptographic key, making no assumptions about which algorithm.</p>
<p id="rfc.section.1.1.p.9">PRIMITIVE PUBLIC KEY / SIGNATURE: A public key or signature object of a non-composite algorithm type.</p>
<p id="rfc.section.1.1.p.10">SIGNATURE: A digital cryptographic signature, making no assumptions about which algorithm.</p>
<p id="rfc.section.1.1.p.11">SHARED SECRET: The output of an exchange of public information between two or more parties that generates a unique shared value for all involved parties.</p>
<p id="rfc.section.1.1.p.12">KEY DERIVATION FUNCTION: A function used to derive secure secret keys using shared secrets, hashing and other cryptographic primitives.</p>
<p id="rfc.section.1.1.p.13">COMPOSITE ENCRYPTION KEY: A structure that contains a sequence of content encryption keys, or secrets used to derive a content encryption keys.</p>
<p id="rfc.section.1.1.p.14">TRIVIAL SECRET SHARING A method to securely share a secret among two or more parties where all parties need to combine their intermediate secret to re-create the secret.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#sec-composite-structs" id="sec-composite-structs">Composite Structures</a>
</h1>
<p id="rfc.section.2.p.1">EDNOTE: TODO: RE-WORK THIS SECTION.</p>
<p id="rfc.section.2.p.2">In order for public keys and signatures to be composed of multiple algorithms, we define encodings consisting of a sequence of public key and signature primitives (aka "component algorithms") such that these structures can be used as a drop-in replacement for existing public key or signature fields such as those found in PKCS#10 <a href="#RFC2986" class="xref">[RFC2986]</a>, CMP <a href="#RFC4210" class="xref">[RFC4210]</a>, X.509 <a href="#RFC5280" class="xref">[RFC5280]</a>, CMS <a href="#RFC5652" class="xref">[RFC5652]</a>.</p>
<p id="rfc.section.2.p.3">This section defines the following structures:</p>
<p></p>

<ul>
<li>The id-alg-composite is an OID identifying a composite encryption object.</li>
<li>The CompositePrivateKey carries all the private keys associated with an identity within a single private key structure.</li>
<li>The CompositeEncryptedeKey is a sequence of encrypted elements that are generated by components of a CompositePrivateKey, and can be verified with the corresponding CompositePublicKey.</li>
</ul>
<p id="rfc.section.2.p.5">EDNOTE 2: the choice to define composite algorithm parameters as a sequence inside the existing fields avoids the exponential proliferation of OIDs that are needed for each combination of signature algorithms in other schemes for achieving multi-key certificates. This scheme also naturally extends from 2-keypair to n-keypair keys and certificates.</p>
<p id="rfc.section.2.p.6">EDNOTE 2a: We have heard community feedback that the ASN.1 structures presented here are too flexible in that allow arbitrary combinations of an arbitrary number of encryption algorithms. The feedback is that this is too much of a "footgun" for implementors and sysadmins. We are working on an alternative formulation using ASN.1 information object classes that allow for compiling explicit pairs of algorithmIDs. We would love community feedback on which approach is preferred. See slide 30 of this presentation: https://datatracker.ietf.org/meeting/interim-2021-lamps-01/materials/slides-interim-2021-lamps-01-sessa-position-presentation-by-mike-ounsworth-00.pdf</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#sec-alg-identifier" id="sec-alg-identifier">Algorithm Identifier</a>
</h1>
<p id="rfc.section.2.1.p.1">The same algorithm identifier is used for identifying a public key, a private key, and a signature.  Additional encoding information is provided below for each of these objects.</p>
<pre>
id-alg-composite OBJECT IDENTIFIER ::= {
    iso(1)  identified-organization(3) dod(6) internet(1) private(4)
    enterprise(1) OpenCA(18227) Algorithms(2) id-alg-composite(1) }
</pre>
<p id="rfc.section.2.1.p.2">EDNOTE 3: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see <a href="#sec-iana" class="xref">Section 7</a>.</p>
<p id="rfc.section.2.1.p.3">EDNOTE: should this be an instance of RFC 5652's KeyEncryptionAlgorithmIdentifier ?</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#composite-keys" id="composite-keys">Composite Keys</a>
</h1>
<p id="rfc.section.2.2.p.1">A Composite encryption MUST be associated with a Composite public key as defined in ~~ reference draft-ounsworth-pq-composite-pubkey ~~.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#key-usage-bits" id="key-usage-bits">Key Usage Bits</a>
</h1>
<p id="rfc.section.2.2.1.p.1">For protocols such as X.509 <a href="#RFC5280" class="xref">[RFC5280]</a> that specify key usage along with the public key, then the composite public key associated with composite encryption MUST have a key usage that either protects a given content encryption key (Key Transport), or produces a content encryption key (Key Agreement)</p>
<p id="rfc.section.2.2.1.p.2">If the keyUsage extension is present in an end-entity certificate whose keys are being used with id-alg-composite encryption, then the keyUsage extension MUST contain one or both of the following values:</p>
<pre>
    keyEncipherment; and keyAgreement
</pre>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#composite-content-key-encryption-using-key-transport" id="composite-content-key-encryption-using-key-transport">Composite Content Key Encryption Using Key Transport</a>
</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#sec-composite-encr-keytrans" id="sec-composite-encr-keytrans">Composite Encryption given a content-encryption key</a>
</h1>
<p id="rfc.section.3.1.p.1">If the underlying component keys support Key Transport, then a content-encryption key may be encrypted using the key transport primitive of its component keys.   All of its component algorithms MUST support key transport for the keyEncipherment usage to be used.</p>
<p id="rfc.section.3.1.p.2">The composite content key encryption algorithm supports encryption and decryption of the content encryption key.  The encryption operation uses a key sharing method as defined in <a href="#sec-composite-keyshare" class="xref">Section 3.1.1</a> to encrypt each intermediate share (the plaintext) under a component algorithm into a ciphertext.   The decryption operation is the inverse operation and each decrypted intermediate share is required to be combined together to obtain the content encryption key.</p>
<p id="rfc.section.3.1.p.3">The id-alg-composite object identifier MUST be used to identify when a content-encryption key has been encrypted by a CompositePrivateKey. Composite encryption uses the following structure:</p>
<p id="rfc.section.3.1.p.4">EDNOTE:  Should a different composite OID be used to determine the type of composite encryption (Key Transport or Key Agreement?).  Probably not because the desired key usage will be described in the underlying protocols.</p>
<pre>
CompositeEncryptedKey ::= EncryptedKey{ SEQUENCE SIZE (1..Max)  OF OCTET STRING}
</pre>
<p id="rfc.section.3.1.p.5">EDNOTE:  Should we use key encapsulation to avoid having implementations having to use padding scheme like OAEP when the Content encryption Key is smaller than the algorithm that is performing the encryption.  For example, RSA 2048 is much larger than an AES-256 bit key, so RSA Padding should be added to the random bit string of length of the content encryption key.   We could use another layer like KEM in RFC 5990 to avoid having to specify padding schemes (or potentially worse, leaving it up to the implementors to decide what to do).   In this case we would need to create a key-encryption key from a random bit string using a KDF and then generate a wrapping key for each intermediate shared secret (See RFC 5990).   Then the SEQUENCE of ASN.1 above would be a OCTET_STRING that is a concatenation of the Cipher Text and the wrapping key.</p>
<p id="rfc.section.3.1.p.6">EDNOTE: Need to run this through an ASN.1 compiler and fix: intent is that this fits into any EncryptedKey field, but defines some structure within the existing EncryptedKey ::= OCTET STRING. If wrapping it on the wire inside the EncryptedKey OID provides that, then great!</p>
<p id="rfc.section.3.1.p.7">Where each OCTET STRING within the SEQUENCE contains the encrypted intermediate content-encryption key material encrypted by one of the component keys. Each OCTET STRING MUST contain one encrypted value produced by the component key in the same order as in the associated composite public key object.</p>
<p id="rfc.section.3.1.p.8">It is recognized there are different ways the content encryption key could be secured.   For example, the content-encryption key could be encrypted in layers.   Component 1 could encrypt the content-encryption key, Component 2 could encrypt the encrypted content encryption key and so fourth.  However this method would likely cause problems if the underlying component produced cipher text that was too large from the next component and thus a complicated padding-block scheme would need to be secured.   A simpler method is a trivial secret sharing scheme as described in <a href="#sec-composite-keyshare" class="xref">Section 3.1.1</a>.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#sec-composite-keyshare" id="sec-composite-keyshare">Content Encryption Key Sharing among n component algorithms</a>
</h1>
<p id="rfc.section.3.1.1.p.1">Random bit strings of the same length as the content encryption key are generated for n-1 component algorithms.  The final bit string is computed by XOR'ing the content encryption key with each of n-1 random bit strings.</p>
<p id="rfc.section.3.1.1.p.2">If n is the number of components, the algorithms works as follows:</p>
<pre>
Input:
     n    The number of component algorithms
     CEK  The Content Encryption Key
     SIZE The size of the Content Encryption Key

Output:
     S1, S2,... Sn       The intermediate shared secrets to be 
                         encapsulated by each component algorithm

Generation Procedure:
   1. Generate a random set of bit strings of the same length as the
      content encryption key
        for i := 1 to n-1
          Si := random_bits(SIZE)

   2. To generate Sn, compute the following
        Sn' = CEK XOR S1 
        for i := 2 to n-1
          Sn' = Sn' (XOR) Si
        Sn = Sn'   

   3. Output S1, S2 ... Sn
</pre>
<p id="rfc.section.3.1.1.p.3">Each intermediate shared secret is then encapsulated by each component algorithm.   To obtain the content-encryption key, each component algorithm MUST be used to decrypt the set of intermediate shared secrets.  These intermediate shared secrets are then XOR'ed together to obtain the content-encryption key.</p>
<p id="rfc.section.3.1.1.p.4">To obtain the content-encryption key from an set of intermediate shared secrets, the following process should be used:</p>
<pre>
Input:
     n                   The number of intermediate shared secrets
     S1, S2,... Sn       The intermediate shared secrets that were 
                         decrypted by each component algorithm

Output:
     CEK  The Content Encryption Key

Generation Procedure:
   1. For each intermediate shared-secret
        CEK' = S1 XOR S2 
        for i := 3 to n
           CEK' = CEK' (XOR) Si
        CEK = CEK'   

   2. Output CEK
</pre>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#sec-composite-encryption-nokeyshare" id="sec-composite-encryption-nokeyshare">Composite Encryption without secret key sharing</a>
</h1>
<p id="rfc.section.3.2.p.1">Each component could encrypt the same content-encryption key.   This would have the effect of removing the security offered by combining component algorithms but it is recognized that this may offer interesting use cases for migration from one type of key to another without having to re-issue keys.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#sec-composite-encr-keytrans-structs" id="sec-composite-encr-keytrans-structs">Composite Content Key Encryption using Key Transport with key derivation</a>
</h1>
<p id="rfc.section.3.3.p.1">A content-encryption key can be generated when intermediate content-encryption keys are used.   A fresh intermediate value of the same length as the desired content encryption key is given to each component algorithm for encryption.   The final content-encryption key can then be derived as specifed in <a href="#sec-key-derivation" class="xref">Section 5.4</a>.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sec-composite-encr-keyagree-structs" id="sec-composite-encr-keyagree-structs">Composite Content Key Encryption using Key Agreement</a>
</h1>
<p id="rfc.section.4.p.1">If the underlying component keys support Key Agreement, then a content-encryption key (for example AES) may be derived and used for the encryption of the plaintext.   All of its component algorithms MUST support key agreement for the keyAgreement usage to be used.</p>
<p id="rfc.section.4.p.2">The composite content encryption key is formed by combining multiple shared secrets produced by each component algorithms.</p>
<p id="rfc.section.4.p.3">The id-alg-composite object identifier MUST be used to identify when a content-encryption encrypted key has been created for decryption by a CompositePrivateKey. Composite encryption uses the following structure:</p>
<pre>
CompositeEncryptedKey ::= EncryptedKey{ SEQUENCE SIZE (1..Max)  OF OCTET STRING}
</pre>
<p id="rfc.section.4.p.4">EDNOTE: do we need a CompositeParams to denote the list of component algorithms used, or will that be implied when the decryptor tries to use their private key? Need to take another look at RFC 5652 and CMP to see if there's even a spot to put CompositeParams in an encryption alg.</p>
<p id="rfc.section.4.p.5">EDNOTE:  I Reviewed RFC 5652 and Parameters are carried in the AlgorithmID fields of the contentEncryptionAlgorithm, KeyEncryptionAlgorithm and KeyDerivationAlgorithm OID values, so the OID used for Composite Encryption can contain the list its component AlgorithmID fields along with each component Algorithms ID's parameters.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#sec-encoding-rules" id="sec-encoding-rules">Encoding Rules</a>
</h1>
<p id="rfc.section.4.1.p.1">EDNOTE: this section was copied from the composite-sigs draft. Does it apply here since I've defined it above as an OCTET STRING already? EDNOTE:   I think keeping this here is fine, one less reference to look up.</p>
<p id="rfc.section.4.1.p.2">Many protocol specifications will require that the composite public key, composite private key, and composite encryption data structures be represented by an octet string or bit string.</p>
<p id="rfc.section.4.1.p.3">When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.</p>
<p id="rfc.section.4.1.p.4">When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.</p>
<p id="rfc.section.4.1.p.5">In the interests of simplicity and avoiding compatibility issues, implementations that parse these structures MAY accept both BER and DER.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sec-composite-encryption-algorithm" id="sec-composite-encryption-algorithm">Composite encryption and decryption Processes</a>
</h1>
<p id="rfc.section.5.p.1">This section specifies the algorithms for encrypting and decrypting using composite encryption.</p>
<p id="rfc.section.5.p.2">This algorithm addresses algorithm strength uncertainty by establishing separate key material using each component algorithm, to be combined into the content encryption key using :: TODO: ref properly :: NIST SP 800-56Cr2.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec-comp-encr-keyTransport" id="sec-comp-encr-keyTransport">Generation of CompositeEncryptedKey using Key Transport</a>
</h1>
<p id="rfc.section.5.1.p.1">The following algorithm is used to generate composite encrypted key values using Key Transport.</p>
<pre>
Input:
     P1, P2, .., Pn    Public keys for the n component encryption
                       algorithms, a CompositePublicKey
    
     S1, S2, .., Sn    (Optional) The intermediate content-encryption 
                       keys usednto form the final content-encryption 
                       key used for the encryption. Generated internally
                       if not passed in. 

Output:
     E                 The encrypted value, a CompositeEncryptedKey

Ciphertext Generation Procedure:
   1. Generate a set of intermediate content-encryption keys used method 
      defined in {{sec-composite-keyshare}}

   2. Generate the n component ciphertexts independently using key 
      transport to wrap each intermediate content-encryption key,
      according to their algorithm specifications.

        for i := 1 to n
            Ei := Encrypt( Pi, Si )

   3. Encode each component ciphertext E1, E2, .., En into a OCTET STRING
      according to its algorithm specification.

        E ::= Sequence { E1, E2, .., En }

   4. Output E
</pre>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#sec-comp-encr-keyAgree" id="sec-comp-encr-keyAgree">Composite encryption using Key Agree</a>
</h1>
<p id="rfc.section.5.2.p.1">Generation of a CompositeEncryptedKey involves applying each component algorithm's encryption routine to a shared secret value according to its specification, and then placing each component value into the CompositeEncryptedKey structure defined in <a href="#sec-composite-encr-keytrans" class="xref">Section 3.1</a>.</p>
<p id="rfc.section.5.2.p.2">The following algorithm is used to generate composite encrypted key values.</p>
<pre>
Input:
     P1, P2, .., Pn     Public keys for the n component encryption
                        algorithms, a CompositePublicKey
    
    SIZE                The size, in bits, for shared secrets to be 
                        combined by both parties into a content 
                        encryption key. This value SHOULD correspond
                        to the size of the content encryption key.

Output:
     E                  The encrypted value, a CompositeEncryptedKey

     SS1, SS2, .., SSn  Key material in the form of a set of shared 
                        secrets.

Ciphertext Generation Procedure:
   1. Generate a set of shared secrets
        for i := 1 to n
          SSi := random_bits(SIZE)

   2. Generate the n component ciphertexts independently,
      according to their algorithm specifications.

        for i := 1 to n
            Ei := Encrypt( Pi, SSi )

   3. Encode each component ciphertext E1, E2, .., En into a OCTET 
      STRING according to its algorithm specification.

        E ::= Sequence { E1, E2, .., En }

   4. Output E
      Output SS1, SS2, .., SSn
</pre>
<p id="rfc.section.5.2.p.3">EDNOTE:  In step 2 above, would it make sense to run the random SS values through a KDF (such as a hash function), and then use that output as the Message from the encryption in step2.   So essentially 1b) could be SSi' = KDF (SSi) which is done before step 2.   Then Step 2 is Ei := Encrypt( Pi, SSi').   If this is agreed, then we can provide a list of accept KDF algorithms as that would be an input.</p>
<p id="rfc.section.5.2.p.4">EDNOTE:  The above process essentially runs through the encryption process N times, and concatenates the results together.   This would produce CipherText output that is at least 2N times as large as a single key encryption process.</p>
<p id="rfc.section.5.2.p.5">EDNOTE:  If we are going to recommend this type of encryption, then I think we should bind each component together so that separate encryption operations cannot be joined together to form a composite encryption, or vice-versa.   This could be done by having each component encrypt a small random value or hash of the pre-encrypted data that could be inserted at the end of the plaintext before being encrypted by each component.  It would be similar to AEAD in GCM or a checksum.</p>
<p id="rfc.section.5.2.p.6">Since recursive composite public keys are disallowed in ~~ Reference draft-ounsworth-pq-composite-pubkeys sec-composite-pub-keys ~~, no component ciphertext may itself be a composite; ie the composite encryption process MUST fail if one of the public keys K1, K2, .., Kn is a composite with the OID id-alg-composite.</p>
<p id="rfc.section.5.2.p.7">A composite encryption MUST produce and include in the output a ciphertext value for every component key in the corresponding CompositePublicKey. For this mode, please see Composite-OR in section <a href="#sec-comp-or-encr" class="xref">Section 5.2.1</a>.</p>
<p id="rfc.section.5.2.p.8">This process MAY be modified to accept the key material SS1, SS2, .., SSn as an input rather than generated as part of this process.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#sec-comp-or-encr" id="sec-comp-or-encr">Composite-OR encryption</a>
</h1>
<p id="rfc.section.5.2.1.p.1">If the algorithm ID of the public key associated with this signature is id-composite-or-key then the encryptor MAY use only a subset of the component keys and therefore produce fewer ciphertexts than the number of recipient component keys.</p>
<p id="rfc.section.5.2.1.p.2">Composite-OR encryption uses the same structures and algorithms as Composite, with the difference that the encryption process may emit a null instead of a ciphertext in step 2 for one or more component algorithms. A Composite-OR CompositeEncryptedKey MUST NOT be entirely null; it must contain at least one ciphertext.</p>
<p id="rfc.section.5.2.1.p.3">The design intent of this mode is to support migration scenarios where an entity is encrypting for a peer which has been issued keys on algorithms that either the encryptor or the recipient do not (yet) support.</p>
<p id="rfc.section.5.2.1.p.4">EDNOTE: Do we want to allow a Composite-OR with only a single ciphertext to produce non-composite EncryptedKey<a href="#RFC5652" class="xref">[RFC5652]</a>? Advantages: bandwidth savings of an extra OID and some sequences with one element. Disadvantages: ambiguous whether a encrypted key is traditional or composite until you look at the corresponding key.</p>
<p id="rfc.section.5.2.1.p.5">EDNOTE:  I do not think we get a lot of value with Composite-OR with a single key because it is essentially just a wrapper around the regular algorithm.  I can see use for systems that recognize the composite structure which may not yet support all the component encryption algorithms, so a composite with algorithms that are not yet understood could be pushed out and one or more of the components could get used.  ## Composite Decryption {#sec-comp-decr}</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#sec-comp-decr-keyAgree" id="sec-comp-decr-keyAgree">Composite decryption using Key Agree</a>
</h1>
<p id="rfc.section.5.3.p.1">The following algorithm is used to decrypt a composite encrypted key values.</p>
<pre>
Input:
    E                  The encrypted value, a CompositeEncryptedKey
    
    K                  Private key for the n component encryption
                       algorithms, a CompositePrivateKey

Output:
     SS1, SS2, .., SSn Key material in the form of a set of shared 
     secrets (intermediate content-encryption keys).

Ciphertext Decryption Procedure:

   1. Parse E into the component ciphertexts

      E1, E2, .., En := Desequence( E )
      K1, K2, .., Kn := Desequence( K )

    If Error during Desequencing, or the three sequences have different 
    numbers of elements, or any of the private keys K1, K2, .., Kn or
    are composite with the OID id-alg-composite then output "Invalid 
    ciphertext" and stop.

   2. Decrypt each component ciphertext individually, according to its
      algorithm specification.  If any fail, then the entire decryption
      operation fails.

        for i := 1 to n
              if not (SSi := decrypt( Ki, Ei ), then
                output "Invalid ciphertext"

   3. Output SS1, SS2, .., SSn
</pre>
<p id="rfc.section.5.3.p.2">Security consideration: for timing-invariance, step 2 may need to process all provided ciphertexsts rather than short-circuiting with an error.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#sec-comp-or-decr" id="sec-comp-or-decr">Composite-OR decryption</a>
</h1>
<p id="rfc.section.5.3.1.p.1">If the decryptor supports using their private key in the Composite-OR mode, then decryption of a null-valued ciphertext in step 2 is not considered an error. The process should emit a null value for the corresponding shared secret SSi, which MUST be treated as an empty string for the purposes of concatenation.</p>
<p id="rfc.section.5.3.1.p.2">EDNOTE:  Have not thought about this yet, but interesting use-cases with key transport because the same content-encryption key could be used for each encryption, which means 1 or more could be used meaning it would lend itself to transition or switching from one algorihtm to another more easily.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#sec-key-derivation" id="sec-key-derivation">Deriving a content encryption key</a>
</h1>
<p id="rfc.section.5.4.p.1">Given a set of shared secrets SS1, SS2, .., SSn as per <a href="#sec-comp-encr-keyAgree" class="xref">Section 5.2</a>, they are to be combined into a content encryption key as:</p>
<pre>
Z := SS1
T := SS2 || .. || SSn
</pre>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">where</th>
<th class="left"></th>
<th class="left">denotes concatenation. Z and T are then used as input to the key derivation scheme defined in :: TODO: CITE PROPERLY :: NIST SP 800-56Cr2 as the "hybrid" shared secret of the form Z' = Z</th>
<th class="left"></th>
<th class="left">T.</th>
</tr></thead>
<tbody><tr></tr></tbody>
</table>
<p id="rfc.section.5.4.p.2">ED NOTE:  https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr2.pdf  section 2.</p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#key-derivation" id="key-derivation">Key Derivation</a>
</h1>
<p id="rfc.section.5.5.p.1">NIST SP 800-56C rev 2 section 4 specifies a 1 step Key Derivation process and section 5 specifies a 2 step Key Derivation Process.   They both require the shared secret Z and a bit length of the output key.  In this context Z' is the concatenation of the shared secrets obtained from each component of the composite encrypted key.  For One-Step Key Derivation, it is recommended that a FIPS 180 or FIPS 202 approved Hash function be used.   For Two-Step Key Derivation an additional salt value is required as part of the input.  Either method may be used to derive the key material.</p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#key-encryption" id="key-encryption">Key encryption</a>
</h1>
<p id="rfc.section.5.6.p.1">EDNOTE: Copy from CMS (RFC 5652):</p>
<p id="rfc.section.5.6.p.2">6.4.  Key-encryption Process</p>
<p id="rfc.section.5.6.p.3">The input to the key-encryption process -- the value supplied to the recipient's key-encryption algorithm -- is just the "value" of the content-encryption key.</p>
<p id="rfc.section.5.6.p.4">Any of the aforementioned key management techniques can be used for each recipient of the same encrypted content.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec-in-pract" id="sec-in-pract">In Practice</a>
</h1>
<p id="rfc.section.6.p.1">This section addresses practical issues of how this draft affects other protocols and standards.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sec-iana" id="sec-iana">IANA Considerations</a>
</h1>
<p id="rfc.section.7.p.1">The ASN.1 module OID is TBD.  The id-alg-composite OID is to be assigned by IANA.  The authors suggest that IANA assign an OID on the id-pkix arc:</p>
<pre>
id-alg-composite OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) algorithms(6) composite(??) }
</pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#policy-for-deprecated-and-acceptable-algorithms" id="policy-for-deprecated-and-acceptable-algorithms">Policy for Deprecated and Acceptable Algorithms</a>
</h1>
<p id="rfc.section.8.1.p.1">Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.</p>
<p id="rfc.section.8.1.p.2">In the composite model this is less obvious since a single public key, certificate, or signature may contain a mixture of deprecated and non-deprecated algorithms. Moreover, implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though neither algorithm is acceptable by itself.</p>
<p id="rfc.section.8.1.p.3">Specifying a modified verification algorithm to handle these situations is beyond the scope of this draft, but could be desirable as the subject of an application profile document, or to be up to the discretion of implementers.</p>
<pre>
2. Check policy to see whether A1, A2, ..., An constitutes a valid
   combination of algorithms.

   if not checkPolicy(A1, A2, ..., An), then
     output "Invalid signature"
</pre>
<p id="rfc.section.8.1.p.4">While intentionally not specified in this document, implementors should put careful thought into implementing a meaningfull policy mechinism within the context of their signature verification engines, for example only algorithms that provide similar security levels should be combined together.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#appendices" id="appendices">Appendices</a>
</h1>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#asn1-module" id="asn1-module">ASN.1 Module</a>
</h1>
<p id="rfc.section.9.1.p.1">EDNOTE: TODO: Update this from the signatures ASN.1.</p>
<pre>
&lt;CODE STARTS&gt;

Composite-Signatures-2019
  { TBD }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
  PUBLIC-KEY, SIGNATURE-ALGORITHM
    FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-algorithmInformation-02(58) }

  SubjectPublicKeyInfo
    FROM PKIX1Explicit-2009
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-pkix1-explicit-02(51) }

  OneAsymmetricKey
    FROM AsymmetricKeyPackageModuleV1
      { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs-9(9) smime(16) modules(0)
        id-mod-asymmetricKeyPkgV1(50) } ;

--
-- Object Identifiers
--

id-alg-composite OBJECT IDENTIFIER ::= { TBD }

--
-- Public Key
--

pk-Composite PUBLIC-KEY ::= {
    IDENTIFIER id-alg-composite
    KEY CompositePublicKey
    PARAMS ARE absent
    PRIVATE-KEY CompositePrivateKey
}

CompositePublicKey ::= SEQUENCE SIZE (1..MAX) OF SubjectPublicKeyInfo

CompositePrivateKey ::= SEQUENCE SIZE (1..MAX) OF OneAsymmetricKey



END

&lt;CODE ENDS&gt;

</pre>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#intellectual-property-considerations" id="intellectual-property-considerations">Intellectual Property Considerations</a>
</h1>
<p id="rfc.section.9.2.p.1">The following IPR Disclosure relates to this draft:</p>
<p id="rfc.section.9.2.p.2">https://datatracker.ietf.org/ipr/3588/</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#contributors-and-acknowledgements" id="contributors-and-acknowledgements">Contributors and Acknowledgements</a>
</h1>
<p id="rfc.section.10.p.1">This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:</p>
<p id="rfc.section.10.p.2">John Gray (Entrust), Serge Mister (Entrust), Scott Fluhrer (Cisco Systems), Panos Kampanakis (Cisco Systems), Daniel Van Geest (ISARA), and Tim Hollebeek (Digicert).</p>
<p id="rfc.section.10.p.3">We are grateful to all, including any contributors who may have been inadvertently omitted from this list.</p>
<p id="rfc.section.10.p.4">This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those documents.  "Copying always makes things easier and less error prone" - <a href="#RFC8411" class="xref">[RFC8411]</a>.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#making-contributions" id="making-contributions">Making contributions</a>
</h1>
<p id="rfc.section.10.1.p.1">Additional contributions to this draft are weclome. Please see the working copy of this draft at, as well as open issues at:</p>
<p id="rfc.section.10.1.p.2">https://github.com/EntrustCorporation/draft-ounsworth-composite-sigs</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC1421">[RFC1421]</b></td>
<td class="top">
<a>Linn, J.</a>, "<a href="https://tools.ietf.org/html/rfc1421">Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures</a>", RFC 1421, DOI 10.17487/RFC1421, February 1993.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2986">[RFC2986]</b></td>
<td class="top">
<a>Nystrom, M.</a> and <a>B. Kaliski</a>, "<a href="https://tools.ietf.org/html/rfc2986">PKCS #10: Certification Request Syntax Specification Version 1.7</a>", RFC 2986, DOI 10.17487/RFC2986, November 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4210">[RFC4210]</b></td>
<td class="top">
<a>Adams, C.</a>, <a>Farrell, S.</a>, <a>Kause, T.</a> and <a>T. Mononen</a>, "<a href="https://tools.ietf.org/html/rfc4210">Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)</a>", RFC 4210, DOI 10.17487/RFC4210, September 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5652">[RFC5652]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="https://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5958">[RFC5958]</b></td>
<td class="top">
<a>Turner, S.</a>, "<a href="https://tools.ietf.org/html/rfc5958">Asymmetric Key Packages</a>", RFC 5958, DOI 10.17487/RFC5958, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7468">[RFC7468]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>S. Leonard</a>, "<a href="https://tools.ietf.org/html/rfc7468">Textual Encodings of PKIX, PKCS, and CMS Structures</a>", RFC 7468, DOI 10.17487/RFC7468, April 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8411">[RFC8411]</b></td>
<td class="top">
<a>Schaad, J.</a> and <a>R. Andrews</a>, "<a href="https://tools.ietf.org/html/rfc8411">IANA Registration for the Cryptographic Algorithm Object Identifier Range</a>", RFC 8411, DOI 10.17487/RFC8411, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="X.690">[X.690]</b></td>
<td class="top">
<a>ITU-T</a>, "<a>Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO/IEC 8825-1:2015, November 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.pala-composite-crypto">[I-D.pala-composite-crypto]</b></td>
<td class="top">
<a>Pala, M.</a>, "<a href="https://tools.ietf.org/html/draft-pala-composite-crypto-00">Composite Public Keys and Signatures</a>", Internet-Draft draft-pala-composite-crypto-00, February 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.truskovsky-lamps-pq-hybrid-x509">[I-D.truskovsky-lamps-pq-hybrid-x509]</b></td>
<td class="top">
<a>Truskovsky, A.</a>, <a>Geest, D.</a>, <a>Fluhrer, S.</a>, <a>Kampanakis, P.</a>, <a>Ounsworth, M.</a> and <a>S. Mister</a>, "<a href="https://tools.ietf.org/html/draft-truskovsky-lamps-pq-hybrid-x509-01">Multiple Public-Key Algorithm X.509 Certificates</a>", Internet-Draft draft-truskovsky-lamps-pq-hybrid-x509-01, August 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Ounsworth</span> 
	  <span class="n hidden">
		<span class="family-name">Ounsworth (Editor)</span>
	  </span>
	</span>
	<span class="org vcardline">Entrust Limited</span>
	<span class="adr">
	  <span class="vcardline">1000 Innovation Drive</span>

	  <span class="vcardline">
		<span class="locality">Ottawa, Ontario</span>,  
		<span class="region"></span>
		<span class="code">K2K 1E3</span>
	  </span>
	  <span class="country-name vcardline">Canada</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mike.ounsworth@entrust.com">mike.ounsworth@entrust.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Gray</span> 
	  <span class="n hidden">
		<span class="family-name">Gray</span>
	  </span>
	</span>
	<span class="org vcardline">Enrust Limited</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:john.gray@entrust.com">john.gray@entrust.com</a></span>

  </address>
</div>

</body>
</html>
